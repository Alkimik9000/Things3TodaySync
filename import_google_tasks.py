"""Import tasks from ``outputs/today_view.csv`` into Google Tasks.

This script reads the CSV generated by extract_tasks.py and inserts each
entry as a task in Google Tasks using OAuth 2.0 credentials.

Credentials are read from ``secrets/credentials.json`` (downloaded from Google
Cloud Console) and the authorization token is stored in ``secrets/token.json``.
"""

from __future__ import annotations

import pandas as pd
import os
import sys
from typing import List, Dict, Optional, Any

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build

SCOPES = ["https://www.googleapis.com/auth/tasks"]
OUTPUT_DIR = os.path.join("outputs")
TODAY_CSV = os.path.join(OUTPUT_DIR, "today_view.csv")
UPCOMING_CSV = os.path.join(OUTPUT_DIR, "upcoming_tasks.csv")
ANYTIME_CSV = os.path.join(OUTPUT_DIR, "anytime_tasks.csv")
TOKEN_FILE = os.path.join("secrets", "token.json")
CREDENTIALS_FILE = os.path.join("secrets", "credentials.json")

# Utility to canonicalise titles for reliable comparison

def canonTitle(title: str) -> str:  # noqa: N802 (keep camelCase rule)
    """Return a canonical representation of a task title.

    Strips leading/trailing whitespace, collapses internal whitespace, and
    converts to lowercase so comparisons are case-insensitive. Emojis and
    other Unicode characters are left intact.
    """
    return " ".join(title.strip().split()).lower()

def getService() -> Any:
    """Authorize the user and return a Google Tasks service instance."""
    creds: Any = None
    if os.path.exists(TOKEN_FILE):
        creds = Credentials.from_authorized_user_file(TOKEN_FILE, SCOPES)

    # Refresh or request new credentials if necessary
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open(TOKEN_FILE, "w") as token:
            assert creds is not None
            token.write(creds.to_json())

    return build("tasks", "v1", credentials=creds)


def readTasksFromCsv(filename: str) -> List[Dict[str, Optional[str]]]:
    """Read tasks from a Things3 today_view.csv file using pandas, removing intra-list duplicates by canonical title."""
    if not os.path.exists(filename):
        return []
    df = pd.read_csv(filename)
    tasks: List[Dict[str, Optional[str]]] = []
    seen_titles: set[str] = set()
    for _, row in df.iterrows():
        title = str(row.get('ItemName', ''))
        notes = str(row.get('Notes', ''))
        due_date = str(row.get('DueDate', ''))
        due_time = str(row.get('DueTime', '')).strip()
        
        # Filter out invalid dates (Things3 uses 4001-01-01 for "someday")
        if due_date and due_date.lower() not in {'nan', 'none', ''}:
            # Check if date is reasonable (between 2000 and 2100)
            try:
                year = int(due_date.split('-')[0])
                if year < 2000 or year > 2100:
                    due_date = ''  # Clear invalid date
            except (ValueError, IndexError):
                due_date = ''  # Clear unparseable date
                
        if due_date and due_date.lower() not in {'nan', 'none', ''}:
            if due_time and due_time.lower() not in {'nan', 'none'}:
                due = due_date + "T" + due_time + ":00.000Z"
            else:
                due = due_date + "T00:00:00.000Z"
        else:
            due = None
        canonical = canonTitle(title)
        if canonical in seen_titles:
            continue  # Skip duplicate by canonical title
        seen_titles.add(canonical)
        tasks.append({'title': title, 'notes': notes, 'due': due})
    return tasks

def readAllTasksWithHierarchy() -> Dict[str, List[Dict[str, Optional[str]]]]:
    """Read all tasks from CSV files and ensure proper hierarchy.
    
    Returns a dict with 'today', 'upcoming', and 'anytime' lists,
    where duplicates are removed according to hierarchy:
    - Today tasks have highest priority
    - Upcoming tasks exclude Today duplicates
    - Anytime tasks exclude both Today and Upcoming duplicates
    """
    # Read all CSV files
    today_tasks = readTasksFromCsv(TODAY_CSV)
    upcoming_tasks = readTasksFromCsv(UPCOMING_CSV)
    anytime_tasks = readTasksFromCsv(ANYTIME_CSV)
    
    # Build canonical title sets for deduplication
    today_canonical = {canonTitle(t['title']) for t in today_tasks if t['title']}
    upcoming_canonical = {canonTitle(t['title']) for t in upcoming_tasks if t['title']}
    
    # Filter upcoming tasks to remove Today duplicates
    upcoming_filtered = [
        t for t in upcoming_tasks 
        if t['title'] and canonTitle(t['title']) not in today_canonical
    ]
    
    # Update upcoming canonical set with filtered tasks
    upcoming_canonical_filtered = {canonTitle(t['title']) for t in upcoming_filtered if t['title']}
    
    # Filter anytime tasks to remove Today and Upcoming duplicates
    anytime_filtered = [
        t for t in anytime_tasks 
        if t['title'] and canonTitle(t['title']) not in (today_canonical | upcoming_canonical_filtered)
    ]
    
    return {
        'today': today_tasks,
        'upcoming': upcoming_filtered,
        'anytime': anytime_filtered
    }

def syncTasks(service: Any, tasklist_id: str, csv_tasks: List[Dict[str, Optional[str]]]) -> None:
    """Synchronise Google Tasks list with tasks from CSV.

    1. Insert or update tasks that exist in the CSV but not in Google Tasks.
    2. Delete tasks from Google Tasks that are no longer present in the CSV.
    3. Remove duplicates in Google Tasks if they exist.
    """

    # Build a mapping of existing Google Tasks (canonical title -> list of tasks)
    existing_tasks_response = service.tasks().list(tasklist=tasklist_id).execute()
    google_tasks_by_canonical: Dict[str, List[Dict[str, Any]]] = {}
    all_google_tasks: List[Dict[str, Any]] = []
    
    for item in existing_tasks_response.get("items", []):
        title_existing: str = str(item.get("title", ""))
        canonical = canonTitle(title_existing)
        task_info = {
            "id": item.get("id", ""),
            "title": title_existing,
            "due": item.get("due"),
            "notes": item.get("notes") or "",
        }
        if canonical not in google_tasks_by_canonical:
            google_tasks_by_canonical[canonical] = []
        google_tasks_by_canonical[canonical].append(task_info)
        all_google_tasks.append(task_info)

    csv_titles_canonical: set[str] = set(
        canonTitle(str(task["title"])) for task in csv_tasks if task["title"] is not None
    )

    # Handle tasks from CSV
    for task in csv_tasks:
        title_current: str = str(task["title"])
        canonical_current: str = canonTitle(title_current)
        
        if canonical_current in google_tasks_by_canonical:
            # Task exists in Google - update the first one and delete any duplicates
            existing_list = google_tasks_by_canonical[canonical_current]
            existing_info = existing_list[0]
            
            # Update the first instance if needed
            body_update: Dict[str, Any] = {}
            if task["due"] and task["due"] != existing_info["due"]:
                body_update["due"] = task["due"]
            if task["notes"] and task["notes"] != existing_info["notes"]:
                body_update["notes"] = task["notes"]
            if body_update:
                service.tasks().patch(
                    tasklist=tasklist_id,
                    task=existing_info["id"],
                    body=body_update,
                ).execute()
                print("Updated task: " + title_current)
            else:
                print("Skipping existing task (no changes): " + title_current)
            
            # Delete any duplicates
            for duplicate in existing_list[1:]:
                service.tasks().delete(tasklist=tasklist_id, task=duplicate["id"]).execute()
                print("Removed duplicate: " + duplicate["title"])
        else:
            # Task doesn't exist - insert it
            body: Dict[str, Any] = {"title": title_current}
            if task["notes"]:
                body["notes"] = task["notes"]
            if task["due"]:
                body["due"] = task["due"]
            service.tasks().insert(tasklist=tasklist_id, body=body).execute()
            print("Inserted task: " + title_current)

    # Remove tasks that are not in CSV
    for canonical_existing, task_list in google_tasks_by_canonical.items():
        if canonical_existing not in csv_titles_canonical:
            for task_info in task_list:
                service.tasks().delete(tasklist=tasklist_id, task=task_info["id"]).execute()
                print("Deleted task: " + task_info["title"])

    # ----- Debug output: lists of titles, gated by env var -----
    if os.getenv("DEBUG_SYNC") == "1":
        print("\n── CSV canonical titles ──")
        for t in sorted(csv_titles_canonical):
            print(t)
        print("\n── Google canonical titles ──")
        for t in sorted(google_tasks_by_canonical.keys()):
            prefix = "DELETE? " if t not in csv_titles_canonical else "KEEP   "
            print(prefix + t)
        print("──────────────────────────\n")
    # ----- End debug output -----

    print("Google Tasks sync completed")


def main() -> None:
    # Determine sync mode from command line arguments
    sync_all = "--all" in sys.argv or "-a" in sys.argv
    
    service = getService()
    
    if sync_all:
        print("Syncing all Things3 lists to Google Tasks...")
        all_tasks = readAllTasksWithHierarchy()
        
        # Get or create task lists
        tasklists = service.tasklists().list().execute()
        list_map = {item['title']: item['id'] for item in tasklists.get('items', [])}
        
        # Ensure we have all required lists
        required_lists = {
            'Today': 'today',
            'Upcoming': 'upcoming', 
            'Anytime': 'anytime'
        }
        
        for list_name, task_key in required_lists.items():
            if list_name not in list_map:
                # Create the list
                new_list = service.tasklists().insert(body={'title': list_name}).execute()
                list_map[list_name] = new_list['id']
                print(f"Created task list: {list_name}")
        
        # Sync each list
        for list_name, task_key in required_lists.items():
            tasks = all_tasks[task_key]
            print(f"\nSyncing {list_name} ({len(tasks)} tasks)...")
            syncTasks(service, list_map[list_name], tasks)
            
        print(f"\nTotal synced: Today={len(all_tasks['today'])}, "
              f"Upcoming={len(all_tasks['upcoming'])}, "
              f"Anytime={len(all_tasks['anytime'])}")
    else:
        # Original behavior - sync only Today to default list
        if not os.path.exists(TODAY_CSV):
            raise FileNotFoundError("CSV file not found: " + TODAY_CSV)
        
        print("Syncing Today view to Google Tasks...")
        
        # Ensure default list is named "Today"
        try:
            service.tasklists().update(
                tasklist='@default',
                body={'title': 'Today'}
            ).execute()
        except Exception as e:
            print(f"Note: Could not update default list name: {e}")
        
        tasks: List[Dict[str, Optional[str]]] = readTasksFromCsv(TODAY_CSV)
        syncTasks(service, "@default", tasks)


if __name__ == "__main__":
    main()
