"""Import tasks from ``outputs/today_view.csv`` into Google Tasks.

This script reads the CSV generated by extract_tasks.py and inserts each
entry as a task in Google Tasks using OAuth 2.0 credentials.

Credentials are read from ``secrets/credentials.json`` (downloaded from Google
Cloud Console) and the authorization token is stored in ``secrets/token.json``.
"""

from __future__ import annotations

import pandas as pd
import os
import sys
import json
from typing import List, Dict, Optional, Any

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build

SCOPES = ["https://www.googleapis.com/auth/tasks"]
OUTPUT_DIR = os.path.join("outputs")
TODAY_CSV = os.path.join(OUTPUT_DIR, "today_view.csv")
UPCOMING_CSV = os.path.join(OUTPUT_DIR, "upcoming_tasks.csv")
ANYTIME_CSV = os.path.join(OUTPUT_DIR, "anytime_tasks.csv")
SOMEDAY_CSV = os.path.join(OUTPUT_DIR, "someday_tasks.csv")
TOKEN_FILE = os.path.join("secrets", "token.json")
CREDENTIALS_FILE = os.path.join("secrets", "credentials.json")
MAPPING_FILE = os.path.join(OUTPUT_DIR, "task_mapping.json")

# Utility to canonicalise titles for reliable comparison

def canonTitle(title: str) -> str:  # noqa: N802 (keep camelCase rule)
    """Return a canonical representation of a task title.

    Strips leading/trailing whitespace, collapses internal whitespace, and
    converts to lowercase so comparisons are case-insensitive. Emojis and
    other Unicode characters are left intact.
    """
    return " ".join(title.strip().split()).lower()

def loadTaskMapping() -> Dict[str, Dict[str, str]]:
    """Load the mapping between Things3 UUIDs and Google Task IDs."""
    if os.path.exists(MAPPING_FILE):
        with open(MAPPING_FILE, 'r') as f:
            return json.load(f)
    return {}

def saveTaskMapping(mapping: Dict[str, Dict[str, str]]) -> None:
    """Save the task mapping to file."""
    os.makedirs(os.path.dirname(MAPPING_FILE), exist_ok=True)
    with open(MAPPING_FILE, 'w') as f:
        json.dump(mapping, f, indent=2)

def getService() -> Any:
    """Authorize the user and return a Google Tasks service instance."""
    creds: Any = None
    if os.path.exists(TOKEN_FILE):
        creds = Credentials.from_authorized_user_file(TOKEN_FILE, SCOPES)

    # Refresh or request new credentials if necessary
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open(TOKEN_FILE, "w") as token:
            assert creds is not None
            token.write(creds.to_json())

    return build("tasks", "v1", credentials=creds)


def readTasksFromCsv(filename: str) -> List[Dict[str, Optional[str]]]:
    """Read tasks from a Things3 CSV file using pandas, removing intra-list duplicates by TaskID and canonical title."""
    if not os.path.exists(filename):
        return []
    df = pd.read_csv(filename)
    # Replace NaN values with empty strings to avoid "nan" in notes
    df = df.fillna('')
    tasks: List[Dict[str, Optional[str]]] = []
    seen_titles: set[str] = set()
    seen_task_ids: set[str] = set()
    for _, row in df.iterrows():
        title = str(row.get('ItemName', ''))
        notes = str(row.get('Notes', ''))
        task_id = str(row.get('TaskID', ''))
        
        # Handle "nan" string that might have been saved
        if notes.lower() == 'nan':
            notes = ''
        
        # Get both date columns - ToDoDate and DueDate
        # Sometimes DueDate has incorrect dates (one month behind)
        # so we'll prioritize ToDoDate if available
        todo_date = str(row.get('ToDoDate', ''))
        due_date = str(row.get('DueDate', ''))
        due_time = str(row.get('DueTime', '')).strip()
        
        # Use ToDoDate if available, otherwise fall back to DueDate
        date_to_use = todo_date if todo_date and todo_date.lower() not in {'nan', 'none', ''} else due_date
        
        # Filter out invalid dates (Things3 uses 4001-01-01 for "someday")
        if date_to_use and date_to_use.lower() not in {'nan', 'none', ''}:
            # Check if date is reasonable (between 2000 and 2100)
            try:
                year = int(date_to_use.split('-')[0])
                if year < 2000 or year > 2100:
                    date_to_use = ''  # Clear invalid date
            except (ValueError, IndexError):
                date_to_use = ''  # Clear unparseable date
                
        if date_to_use and date_to_use.lower() not in {'nan', 'none', ''}:
            if due_time and due_time.lower() not in {'nan', 'none'}:
                due = date_to_use + "T" + due_time + ":00.000Z"
            else:
                due = date_to_use + "T00:00:00.000Z"
        else:
            due = None
        
        # Skip duplicates by TaskID first, then by canonical title
        if task_id and task_id in seen_task_ids:
            continue  # Skip duplicate by TaskID
        canonical = canonTitle(title)
        if canonical in seen_titles:
            continue  # Skip duplicate by canonical title
            
        if task_id:
            seen_task_ids.add(task_id)
        seen_titles.add(canonical)
        tasks.append({'title': title, 'notes': notes, 'due': due, 'task_id': task_id})
    return tasks

def readAllTasksWithHierarchy() -> Dict[str, List[Dict[str, Optional[str]]]]:
    """Read all tasks from CSV files and ensure proper hierarchy.
    
    Returns a dict with 'today', 'upcoming', 'anytime', and 'someday' lists,
    where duplicates are removed according to hierarchy:
    - Today tasks have highest priority
    - Upcoming tasks exclude Today duplicates
    - Anytime tasks exclude both Today and Upcoming duplicates
    - Someday tasks exclude Today, Upcoming, and Anytime duplicates
    """
    # Read all CSV files
    today_tasks = readTasksFromCsv(TODAY_CSV)
    upcoming_tasks = readTasksFromCsv(UPCOMING_CSV)
    anytime_tasks = readTasksFromCsv(ANYTIME_CSV)
    someday_tasks = readTasksFromCsv(SOMEDAY_CSV)
    
    # Build sets for deduplication using both TaskIDs and canonical titles
    today_task_ids = {t['task_id'] for t in today_tasks if t.get('task_id')}
    today_canonical = {canonTitle(t['title']) for t in today_tasks if t['title']}
    
    # Filter upcoming tasks to remove Today duplicates
    upcoming_filtered = []
    for t in upcoming_tasks:
        # Skip if TaskID matches
        if t.get('task_id') and t['task_id'] in today_task_ids:
            continue
        # Skip if title matches
        if t['title'] and canonTitle(t['title']) in today_canonical:
            continue
        upcoming_filtered.append(t)
    
    # Update sets with filtered upcoming tasks
    upcoming_task_ids = {t['task_id'] for t in upcoming_filtered if t.get('task_id')}
    upcoming_canonical = {canonTitle(t['title']) for t in upcoming_filtered if t['title']}
    
    # Filter anytime tasks to remove Today and Upcoming duplicates
    anytime_filtered = []
    for t in anytime_tasks:
        # Skip if TaskID matches
        if t.get('task_id') and t['task_id'] in (today_task_ids | upcoming_task_ids):
            continue
        # Skip if title matches
        if t['title'] and canonTitle(t['title']) in (today_canonical | upcoming_canonical):
            continue
        anytime_filtered.append(t)
    
    # Update sets with filtered anytime tasks
    anytime_task_ids = {t['task_id'] for t in anytime_filtered if t.get('task_id')}
    anytime_canonical = {canonTitle(t['title']) for t in anytime_filtered if t['title']}
    
    # Filter someday tasks to remove Today, Upcoming, and Anytime duplicates
    someday_filtered = []
    for t in someday_tasks:
        # Skip if TaskID matches
        if t.get('task_id') and t['task_id'] in (today_task_ids | upcoming_task_ids | anytime_task_ids):
            continue
        # Skip if title matches
        if t['title'] and canonTitle(t['title']) in (today_canonical | upcoming_canonical | anytime_canonical):
            continue
        someday_filtered.append(t)
    
    return {
        'today': today_tasks,
        'upcoming': upcoming_filtered,
        'anytime': anytime_filtered,
        'someday': someday_filtered
    }

def syncTasks(service: Any, tasklist_id: str, csv_tasks: List[Dict[str, Optional[str]]]) -> None:
    """Synchronise Google Tasks list with tasks from CSV.
    
    1. Insert or update tasks that exist in the CSV but not in Google Tasks.
    2. Delete tasks from Google Tasks that are no longer present in the CSV.
    3. Remove duplicates in Google Tasks if they exist.
    """
    
    # Load task mapping
    task_mapping = loadTaskMapping()

    # Build a mapping of existing Google Tasks (canonical title -> list of tasks)
    # Use pagination to get ALL tasks
    google_tasks_by_canonical: Dict[str, List[Dict[str, Any]]] = {}
    all_google_tasks: List[Dict[str, Any]] = []
    
    page_token = None
    while True:
        if page_token:
            existing_tasks_response = service.tasks().list(tasklist=tasklist_id, pageToken=page_token, maxResults=100).execute()
        else:
            existing_tasks_response = service.tasks().list(tasklist=tasklist_id, maxResults=100).execute()
        
        for item in existing_tasks_response.get("items", []):
            title_existing: str = str(item.get("title", ""))
            canonical = canonTitle(title_existing)
            task_info = {
                "id": item.get("id", ""),
                "title": title_existing,
                "due": item.get("due"),
                "notes": item.get("notes") or "",
            }
            if canonical not in google_tasks_by_canonical:
                google_tasks_by_canonical[canonical] = []
            google_tasks_by_canonical[canonical].append(task_info)
            all_google_tasks.append(task_info)
        
        page_token = existing_tasks_response.get("nextPageToken")
        if not page_token:
            break

    csv_titles_canonical: set[str] = set(
        canonTitle(str(task["title"])) for task in csv_tasks if task["title"] is not None
    )

    # Handle tasks from CSV
    for task in csv_tasks:
        title_current: str = str(task["title"])
        canonical_current: str = canonTitle(title_current)
        
        if canonical_current in google_tasks_by_canonical:
            # Task exists in Google - update the first one and delete any duplicates
            existing_list = google_tasks_by_canonical[canonical_current]
            existing_info = existing_list[0]
            
            # Update the first instance if needed
            body_update: Dict[str, Any] = {}
            if task["due"] and task["due"] != existing_info["due"]:
                body_update["due"] = task["due"]
            # Fix: Check for "nan" string and treat as empty
            task_notes = task["notes"] if task["notes"] and task["notes"].lower() != "nan" else ""
            if task_notes != existing_info["notes"]:
                body_update["notes"] = task_notes
            if body_update:
                service.tasks().patch(
                    tasklist=tasklist_id,
                    task=existing_info["id"],
                    body=body_update,
                ).execute()
                print("Updated task: " + title_current)
            else:
                print("Skipping existing task (no changes): " + title_current)
            
            # Delete any duplicates
            for duplicate in existing_list[1:]:
                service.tasks().delete(tasklist=tasklist_id, task=duplicate["id"]).execute()
                print("Removed duplicate: " + duplicate["title"])
        else:
            # Task doesn't exist - insert it
            body: Dict[str, Any] = {"title": title_current}
            # Fix: Check for "nan" string and treat as empty
            if task["notes"] and task["notes"].lower() != "nan":
                body["notes"] = task["notes"]
            if task["due"]:
                body["due"] = task["due"]
            result = service.tasks().insert(tasklist=tasklist_id, body=body).execute()
            print("Inserted task: " + title_current)
            
            # Save mapping if task has a Things3 UUID
            things_uuid = task.get("task_id")
            google_id = result.get("id")
            if things_uuid and google_id:
                task_mapping[things_uuid] = {
                    "google_id": google_id,
                    "title": title_current,
                    "last_synced": result.get("updated", "")
                }

    # Remove tasks that are not in CSV
    for canonical_existing, task_list in google_tasks_by_canonical.items():
        if canonical_existing not in csv_titles_canonical:
            for task_info in task_list:
                service.tasks().delete(tasklist=tasklist_id, task=task_info["id"]).execute()
                print("Deleted task: " + task_info["title"])

    # ----- Debug output: lists of titles, gated by env var -----
    if os.getenv("DEBUG_SYNC") == "1":
        print("\n── CSV canonical titles ──")
        for t in sorted(csv_titles_canonical):
            print(t)
        print("\n── Google canonical titles ──")
        for t in sorted(google_tasks_by_canonical.keys()):
            prefix = "DELETE? " if t not in csv_titles_canonical else "KEEP   "
            print(prefix + t)
        print("──────────────────────────\n")
    # ----- End debug output -----

    # Save the updated mapping
    saveTaskMapping(task_mapping)
    print("Google Tasks sync completed")

def syncAllListsWithCrossCheck(service: Any, all_tasks: Dict[str, List[Dict[str, Optional[str]]]]) -> None:
    """Sync all lists and ensure no task appears in multiple lists."""
    # Get or create task lists
    tasklists = service.tasklists().list().execute()
    list_map = {item['title']: item['id'] for item in tasklists.get('items', [])}
    
    # Ensure we have all required lists
    required_lists = {
        'Today': 'today',
        'Upcoming': 'upcoming', 
        'Anytime': 'anytime',
        'Someday': 'someday'
    }
    
    for list_name, task_key in required_lists.items():
        if list_name not in list_map:
            # Create the list
            new_list = service.tasklists().insert(body={'title': list_name}).execute()
            list_map[list_name] = new_list['id']
            print("Created task list: " + list_name)
    
    # Build a map of canonical titles to their designated list
    canonical_to_list: Dict[str, str] = {}
    for list_name, task_key in required_lists.items():
        for task in all_tasks[task_key]:
            if task['title']:  # Only process if title is not None
                canonical = canonTitle(task['title'])
                canonical_to_list[canonical] = list_name
    
    # First, remove tasks that are in the wrong lists
    print("\nChecking for tasks in wrong lists...")
    for list_name in required_lists:
        list_id = list_map[list_name]
        
        # Get all tasks with pagination
        page_token = None
        while True:
            if page_token:
                response = service.tasks().list(tasklist=list_id, pageToken=page_token, maxResults=100).execute()
            else:
                response = service.tasks().list(tasklist=list_id, maxResults=100).execute()
            
            for item in response.get("items", []):
                canonical = canonTitle(item.get("title", ""))
                # If this task belongs to a different list, remove it from this one
                if canonical in canonical_to_list and canonical_to_list[canonical] != list_name:
                    service.tasks().delete(tasklist=list_id, task=item['id']).execute()
                    print("Removed '" + item.get("title", "") + "' from " + list_name + " (belongs in " + canonical_to_list[canonical] + ")")
            
            page_token = response.get("nextPageToken")
            if not page_token:
                break
    
    # Now sync each list normally
    for list_name, task_key in required_lists.items():
        tasks = all_tasks[task_key]
        print("\nSyncing " + list_name + " (" + str(len(tasks)) + " tasks)...")
        syncTasks(service, list_map[list_name], tasks)

def main() -> None:
    # Determine sync mode from command line arguments
    sync_all = "--all" in sys.argv or "-a" in sys.argv
    
    service = getService()
    
    if sync_all:
        print("Syncing all Things3 lists to Google Tasks...")
        all_tasks = readAllTasksWithHierarchy()
        
        # Use the new cross-check sync function
        syncAllListsWithCrossCheck(service, all_tasks)
            
        print("\nTotal synced: Today=" + str(len(all_tasks['today'])) + ", " +
              "Upcoming=" + str(len(all_tasks['upcoming'])) + ", " +
              "Anytime=" + str(len(all_tasks['anytime'])) + ", " +
              "Someday=" + str(len(all_tasks['someday'])))
    else:
        # Original behavior - sync only Today to default list
        if not os.path.exists(TODAY_CSV):
            raise FileNotFoundError("CSV file not found: " + TODAY_CSV)
        
        print("Syncing Today view to Google Tasks...")
        
        # Ensure default list is named "Today"
        try:
            service.tasklists().update(
                tasklist='@default',
                body={'title': 'Today'}
            ).execute()
        except Exception as e:
            print("Note: Could not update default list name: " + str(e))
        
        tasks: List[Dict[str, Optional[str]]] = readTasksFromCsv(TODAY_CSV)
        syncTasks(service, "@default", tasks)


if __name__ == "__main__":
    main()
