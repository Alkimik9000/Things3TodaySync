"""Import tasks from ``outputs/today_view.csv`` into Google Tasks.

This script reads the CSV generated by extract_tasks.py and inserts each
entry as a task in Google Tasks using OAuth 2.0 credentials.

Credentials are read from ``secrets/credentials.json`` (downloaded from Google
Cloud Console) and the authorization token is stored in ``secrets/token.json``.
"""

from __future__ import annotations

import pandas as pd
import os
import sys
from typing import List, Dict, Optional, Any

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build

SCOPES = ["https://www.googleapis.com/auth/tasks"]
OUTPUT_DIR = os.path.join("outputs")
TODAY_CSV = os.path.join(OUTPUT_DIR, "today_view.csv")
UPCOMING_CSV = os.path.join(OUTPUT_DIR, "upcoming_tasks.csv")
ANYTIME_CSV = os.path.join(OUTPUT_DIR, "anytime_tasks.csv")
TOKEN_FILE = os.path.join("secrets", "token.json")
CREDENTIALS_FILE = os.path.join("secrets", "credentials.json")

# Utility to canonicalise titles for reliable comparison

def canonTitle(title: str) -> str:  # noqa: N802 (keep camelCase rule)
    """Return a canonical representation of a task title.

    Strips leading/trailing whitespace, collapses internal whitespace, and
    converts to lowercase so comparisons are case-insensitive. Emojis and
    other Unicode characters are left intact.
    """
    return " ".join(title.strip().split()).lower()

def getService() -> Any:
    """Authorize the user and return a Google Tasks service instance."""
    creds: Any = None
    if os.path.exists(TOKEN_FILE):
        creds = Credentials.from_authorized_user_file(TOKEN_FILE, SCOPES)

    # Refresh or request new credentials if necessary
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open(TOKEN_FILE, "w") as token:
            assert creds is not None
            token.write(creds.to_json())

    return build("tasks", "v1", credentials=creds)


def readTasksFromCsv(filename: str) -> List[Dict[str, Optional[str]]]:
    """Read tasks from a Things3 today_view.csv file using pandas."""
    if not os.path.exists(filename):
        return []
    df = pd.read_csv(filename)
    tasks: List[Dict[str, Optional[str]]] = []
    for _, row in df.iterrows():
        title = str(row.get('ItemName', ''))
        notes = str(row.get('Notes', ''))
        due_date = str(row.get('DueDate', ''))
        due_time = str(row.get('DueTime', '')).strip()
        
        # Filter out invalid dates (Things3 uses 4001-01-01 for "someday")
        if due_date and due_date.lower() not in {'nan', 'none', ''}:
            # Check if date is reasonable (between 2000 and 2100)
            try:
                year = int(due_date.split('-')[0])
                if year < 2000 or year > 2100:
                    due_date = ''  # Clear invalid date
            except (ValueError, IndexError):
                due_date = ''  # Clear unparseable date
                
        if due_date and due_date.lower() not in {'nan', 'none', ''}:
            if due_time and due_time.lower() not in {'nan', 'none'}:
                due = f"{due_date}T{due_time}:00.000Z"
            else:
                due = f"{due_date}T00:00:00.000Z"
        else:
            due = None
        tasks.append({'title': title, 'notes': notes, 'due': due})
    return tasks

def readAllTasksWithHierarchy() -> Dict[str, List[Dict[str, Optional[str]]]]:
    """Read all tasks from CSV files and ensure proper hierarchy.
    
    Returns a dict with 'today', 'upcoming', and 'anytime' lists,
    where duplicates are removed according to hierarchy:
    - Today tasks have highest priority
    - Upcoming tasks exclude Today duplicates
    - Anytime tasks exclude both Today and Upcoming duplicates
    """
    # Read all CSV files
    today_tasks = readTasksFromCsv(TODAY_CSV)
    upcoming_tasks = readTasksFromCsv(UPCOMING_CSV)
    anytime_tasks = readTasksFromCsv(ANYTIME_CSV)
    
    # Build canonical title sets for deduplication
    today_canonical = {canonTitle(t['title']) for t in today_tasks if t['title']}
    upcoming_canonical = {canonTitle(t['title']) for t in upcoming_tasks if t['title']}
    
    # Filter upcoming tasks to remove Today duplicates
    upcoming_filtered = [
        t for t in upcoming_tasks 
        if t['title'] and canonTitle(t['title']) not in today_canonical
    ]
    
    # Update upcoming canonical set with filtered tasks
    upcoming_canonical_filtered = {canonTitle(t['title']) for t in upcoming_filtered if t['title']}
    
    # Filter anytime tasks to remove Today and Upcoming duplicates
    anytime_filtered = [
        t for t in anytime_tasks 
        if t['title'] and canonTitle(t['title']) not in (today_canonical | upcoming_canonical_filtered)
    ]
    
    return {
        'today': today_tasks,
        'upcoming': upcoming_filtered,
        'anytime': anytime_filtered
    }

def syncTasks(service: Any, tasklist_id: str, csv_tasks: List[Dict[str, Optional[str]]]) -> None:
    """Synchronise Google Tasks list with tasks from CSV.

    1. Insert or update tasks that exist in the CSV but not in Google Tasks.
    2. Delete tasks from Google Tasks that are no longer present in the CSV.
    """

    # Build a mapping of existing Google Tasks (canonical title -> id)
    existing_tasks_response = service.tasks().list(tasklist=tasklist_id).execute()
    google_tasks: Dict[str, Dict[str, Any]] = {}
    for item in existing_tasks_response.get("items", []):
        title_existing: str = str(item.get("title", ""))
        google_tasks[canonTitle(title_existing)] = {
            "id": item.get("id", ""),
            "due": item.get("due"),
            "notes": item.get("notes") or "",
        }

    csv_titles_canonical: set[str] = set(
        canonTitle(str(task["title"])) for task in csv_tasks if task["title"] is not None
    )

    # Insert missing tasks
    for task in csv_tasks:
        title_current: str = str(task["title"])
        canonical_current: str = canonTitle(title_current)
        if canonical_current in google_tasks:
            existing_info = google_tasks[canonical_current]
            body_update: Dict[str, Any] = {}
            # Compare due date
            if task["due"] and task["due"] != existing_info["due"]:
                body_update["due"] = task["due"]
            # Compare notes
            if task["notes"] and task["notes"] != existing_info["notes"]:
                body_update["notes"] = task["notes"]
            if body_update:
                service.tasks().patch(
                    tasklist=tasklist_id,
                    task=existing_info["id"],
                    body=body_update,
                ).execute()
                print("Updated task: " + title_current)
            else:
                print("Skipping existing task (no changes): " + title_current)
            continue

        body: Dict[str, Any] = {"title": title_current}
        if task["notes"]:
            body["notes"] = task["notes"]
        if task["due"]:
            body["due"] = task["due"]
        service.tasks().insert(tasklist=tasklist_id, body=body).execute()
        print("Inserted task: " + title_current)

    # Remove tasks that are not in CSV
    for canonical_existing, info in google_tasks.items():
        if canonical_existing not in csv_titles_canonical:
            service.tasks().delete(tasklist=tasklist_id, task=info["id"]).execute()
            print("Deleted task with canonical title: " + canonical_existing)

    # ----- Debug output: lists of titles, gated by env var -----
    if os.getenv("DEBUG_SYNC") == "1":
        print("\n── CSV canonical titles ──")
        for t in sorted(csv_titles_canonical):
            print(t)
        print("\n── Google canonical titles ──")
        for t in sorted(google_tasks.keys()):
            prefix = "DELETE? " if t not in csv_titles_canonical else "KEEP   "
            print(prefix + t)
        print("──────────────────────────\n")
    # ----- End debug output -----

    print("Google Tasks sync completed")


def main() -> None:
    # Determine sync mode from command line arguments
    sync_all = "--all" in sys.argv or "-a" in sys.argv
    
    service = getService()
    
    if sync_all:
        print("Syncing all Things3 lists to Google Tasks...")
        all_tasks = readAllTasksWithHierarchy()
        
        # Get or create task lists
        tasklists = service.tasklists().list().execute()
        list_map = {item['title']: item['id'] for item in tasklists.get('items', [])}
        
        # Ensure we have all required lists
        required_lists = {
            'Today': 'today',
            'Upcoming': 'upcoming', 
            'Anytime': 'anytime'
        }
        
        for list_name, task_key in required_lists.items():
            if list_name not in list_map:
                # Create the list
                new_list = service.tasklists().insert(body={'title': list_name}).execute()
                list_map[list_name] = new_list['id']
                print(f"Created task list: {list_name}")
        
        # Sync each list
        for list_name, task_key in required_lists.items():
            tasks = all_tasks[task_key]
            print(f"\nSyncing {list_name} ({len(tasks)} tasks)...")
            syncTasks(service, list_map[list_name], tasks)
            
        print(f"\nTotal synced: Today={len(all_tasks['today'])}, "
              f"Upcoming={len(all_tasks['upcoming'])}, "
              f"Anytime={len(all_tasks['anytime'])}")
    else:
        # Original behavior - sync only Today to default list
        if not os.path.exists(TODAY_CSV):
            raise FileNotFoundError("CSV file not found: " + TODAY_CSV)
        
        print("Syncing Today view to Google Tasks...")
        
        # Ensure default list is named "Today"
        try:
            service.tasklists().update(
                tasklist='@default',
                body={'title': 'Today'}
            ).execute()
        except Exception as e:
            print(f"Note: Could not update default list name: {e}")
        
        tasks: List[Dict[str, Optional[str]]] = readTasksFromCsv(TODAY_CSV)
        syncTasks(service, "@default", tasks)


if __name__ == "__main__":
    main()
